\include{preamble.tex}

\date{\today}
\title{MPC for Group Reconstruction Circuits}
\author{Lúcás Críostóir Meier}

\begin{document}

\maketitle

\begin{abstract}
    In this paper, we present a thing.
\end{abstract}

\section{Introduction}

\todo{Write the introduction}

\section{Background}

Throughout this paper, we let $\G$ denote a group of prime order $q$,
with generators $G$ and $H$. Let $\Fq$ denote the scalar field associated
with this group, and let $\Zq$ denote the additive group of elements
in this field.

We make heavy use of group homomorphisms throughout this paper.
We let
$$
\varphi(P_1, \ldots, P_m) : \mathbb{A} \to \mathbb{B}
$$
denote a homomorphism from $\mathbb{A}$ to $\mathbb{B}$, parameterized
by some public values $P_1, \ldots, P_m$. Commonly $\mathbb{A}$
will be a product of several groups $\mathbb{G}_1, \ldots, \mathbb{G}_n$,
in which case we'd write:
$$
\varphi(P_1, \ldots, P_m)(x_1, \ldots, x_n)
$$
to denote the application of $\varphi$ to an element $(x_1, \ldots, x_n)$
of the product group. The public values $P_i$ are often left implicit.

We often write products $(x_1, \ldots, x_n)$ as a single vector
$\bx \in \mathbb{A}^n$. Operations between these vectors
are done element-wise, so we write $\bx + \by$ for ${(x_1 + y_1, \ldots, x_n + y_n)}$,
as well as $\bx \cdot G$ for $(x_1 \cdot G, \ldots, x_n \cdot G)$.

\subsection{Pedersen Commitments}

A key component of our scheme are Pedersen commitments \cite{pedersen_non-interactive_1992}.
In their basic form, they allow one to commit to a value in $x \in \Zq$. This
is done by sampling a random $r \xleftarrow{R} \Zq$, and forming the commitment:
$$
\text{Com}(x, r) := x \cdot G + r \cdot H
$$
where $H$ is a generator of $\mathbb{G}$, independent from $G$.

This scheme is \emph{perfectly hiding}, because $r \cdot H$ acts like
a random element of $\mathbb{G}$, and completely masks $x \cdot G$.

On the other hand, this scheme is only \emph{computationally} binding. This
is because the discrete logarithm $H$ with respect to $G$ must be kept hidden.
If the discrete logarithm of $H$ is known, then it becomes possible to
\emph{equivocate}, by finding two inputs $(x, r)$ and $(x', r')$ with
equal commitments, i.e. $\text{Com}(x, r) = \text{Com}(x', r')$.

In fact, we can more precisely characterize this property: knowing
the discrete logarithm of $H$ is \emph{necessary} in order to be able
to equivocate.

\begin{claim}
    Given two inputs $(x, r)$ and $(x', r')$ such that ${\text{Com}(x, r) = \text{Com}(x', r')}$,
    it's possible to efficiently compute a value $h$ such that $h \cdot G = H$.
\end{claim}

The proof is just a matter of algebra:

$$
\begin{aligned}
x \cdot G + r \cdot H &= x' \cdot G + r' \cdot H\\
(x - x') \cdot G &= (r' - r) \cdot H\\
\frac{(x - x')}{(r' - r)} \cdot G &= H\\
\end{aligned}
$$

Thus $(x - x') / (r' - r)$ is our discrete logarithm.

$\square$


\subsection{Sigma Protocols}

\subsection{Maurer's \texorpdfstring{$\varphi$}{varphi}-Proof}

In \cite{maurer_unifying_2009}, Maurer generalized Schnorr's sigma 
protocol for knowledge of the discrete logarithm \cite{schnorr_efficient_1990} to a much larger class
of relations. In particular, Maurer provided a sigma protocol for
proving knowledge of the pre-image of a group homomorphism $\varphi$.
We denote this protocol as a ``$\varphi$-proof'', and recapitulate the scheme
here.

Given a homomorphism $\varphi : \mathbb{A} \to \mathbb{B}$, and a public value
$X \in \mathbb{B}$, the prover wants to demonstrate knowledge of a private
value $x \in \mathbb{A}$ such that $\varphi(x) = X$. The prover
does this by means of Protocol \ref{prot:phiproof}:

\begin{aprotocol}{prot:phiproof}{$\varphi$-Proof}
\[
\begin{aligned}
    &\textbf{Prover}&&\textbf{Verifier}\\
    &\text{knows } x \in \mathbb{A}&&\text{public } X \in \mathbb{B}\\
    \\
    &k \xleftarrow{R} \mathbb{A}&\\
    &K \gets \varphi(k)&\\
    &&\quad\overset{K}{\longrightarrow}\quad\\
    &&&c \xleftarrow{R} \mathbb{Z}/(p)\\
    &&\quad\overset{c}{\longleftarrow}\quad\\
    &s \gets k + c \cdot x\\
    &&\quad\overset{s}{\longrightarrow}\quad\\
    &&& \varphi(s) \overset{?}{=} K + c \cdot X\\
\end{aligned}
\]
\end{aprotocol}

Here, $p$ is chosen such that $\forall B \in \mathbb{B}.\ p \cdot B = 0$.
In practice, we'll set $p = q$, which will work perfectly for the groups
we use, which are all products of $\G$ or $\Zq$.

\begin{claim}
    Protocol \ref{prot:phiproof} is a valid sigma protocol.
\end{claim}

Completeness follows directly from the fact that $\varphi$ is a homomorphism.

For the HVZK property, the simulator $\mathcal{S}(X, c)$ works by generating
a random $s \xleftarrow{R} \mathbb{A}$, and then setting $K := \varphi(S) - c \cdot X$.

Finally, we prove $2$-extractability. Given two verifying transcripts
$(K, c, s)$ and $(K, c', s')$ sharing the first message, we extract
a value $\hat{x}$ satisfying $\varphi(\hat{x}) = X$ as follows:

$$
\begin{aligned}
\varphi(s) - c \cdot X &= K = \varphi(s') - c' \cdot X\\
\varphi(s) - \varphi(s') &= c \cdot X - c' \cdot X\\
\frac{1}{c - c'} \cdot \varphi(s - s') &= X\\
\varphi \left(\frac{s - s'}{c - c'}\right) &= X
\end{aligned}
$$

Thus, defining $\hat{x} := (s - s') / (c - c')$, we successfully extract
a valid pre-image.

We conclude that the protocol is a valid sigma protocol.

$\blacksquare$

Maurer's protocol can also work even in the case where the order of
the groups are not known, but this makes the challenge generation
a bit more complicated, and we don't need this functionality in
this work.

\subsection{UC Security and the Hybrid Model}

\subsection{Ideal Functionalities for Sigma Protocols}

\begin{afunctionality}{fun:zk}{Zero-Knowledge Functionality $\mathcal{F}(\texttt{ZK}, \varphi)$}
A functionality $\mathcal{F}$ for parties $P_1, \ldots, P_n$.\\
\\
On input $(\texttt{prove}, \sid, x)$ from $P_i$:\\
$\mathcal{F}$ checks that $\sid$ has not been used by $P_i$ before.\\
$\mathcal{F}$ generates a new token $\pi$, and sets $x_\pi \gets x$.\\
$\mathcal{F}$ replies with $(\texttt{proof}, \pi)$.\\
\\
On input $(\texttt{verify}, X, \pi)$:\\
$\mathcal{F}$ replies with $(\texttt{verify-result}, \varphi(x_\pi) \stackrel{?}{=} X)$.\\


\end{afunctionality}

\subsection{Broadcast Functionalities}

\begin{afunctionality}{fun:broadcast}{Authenticated Broadcast Functionality $\mathcal{C}$}
A functionality $\mathcal{C}$ for parties $P_1, \ldots, P_n$.\\
\\
On receiving $(\texttt{broadcast-in}, \sid, m)$ from $P_i$:\\
$\mathcal{C}$ checks that $\sid$ has not been used by $P_i$ before.\\
$\mathcal{C}$ sends $(\texttt{broadcast-out}, \pid_i, \sid, m)$ to every party $P_j$.
\end{afunctionality}

\section{Group Reconstruction Circuits}

\subsection{Formal Definition}

\subsection{Normalized Form}

\section{MPC Protocol for GRCs}

\subsection{Ideal Functionality}

\begin{afunctionality}{fun:mpc}{GRC functionality $\mathcal{F}(\texttt{GRC}, \Phi, \textbf{X}^j, \textbf{Y}^j)$}
A functionality $\mathcal{F}$ for parties $P_1, \ldots, P_n$.\\
\\
After receiving
$(\texttt{input}, \texttt{sid}, \textbf{x}^j, \textbf{y}^j, \boldsymbol{\alpha}^j, \textbf{k}^j)$ from every party $P_j$:\\
$\mathcal{F}$ checks, for every $j \in [n]$, that:
$$
\begin{aligned}
    \textbf{X}^j &\stackrel{?}{=} \textbf{x}^j \cdot G\\
    \textbf{Y}^j &\stackrel{?}{=} \textbf{y}^j \cdot G + \boldsymbol{\alpha}^j \cdot H\\
\end{aligned}
$$
$\mathcal{F}$ computes, for each round $r \in [d]$:
$$
\begin{aligned}
    \textbf{V}^j_{r} &:= \varphi_{r}(\textbf{V}_{1}, \ldots, \textbf{V}_{r - 1})(
        \textbf{x}^j, \textbf{y}^j, \textbf{k}^j
    )\\
    \textbf{V}_r &:= \sum_j \textbf{V}^j_r
\end{aligned}
$$\\
$\mathcal{F}$ sends $(\texttt{output}, \texttt{sid}, \textbf{V}^1_1, \ldots, \textbf{V}^n_d)$ to every party $P_j$.
\end{afunctionality}

\subsection{Protocol}

$$
\psi_r(\textbf{x}, \textbf{y}, \boldsymbol{\alpha}, \textbf{k}, \boldsymbol{\beta})
:= (\varphi_r(\textbf{x}, \textbf{y}, \textbf{j}), \bx \cdot G, \text{Commit}(\textbf{y}, \boldsymbol{\alpha}), \text{Commit}(\textbf{k}, \boldsymbol{\beta}))
$$

\begin{aprotocol}{prot:mpc}{MPC protocol for $\Phi, \textbf{X}^j, \textbf{Y}^j$}

Each party $P_j$ has inputs $\textbf{x}^j$ and $\textbf{y}^j$, committed to
by $\textbf{X}^j$ and $\textbf{Y}^j$.
They also have decommitments $\boldsymbol{\alpha}^j$ for $\textbf{Y}^j$.
Each party $P_j$ also has a vector $\textbf{k}^j$, which honest parties will
have generated randomly.\\
\\
\textbf{Round 0}\\
Each party $P_j$ generates a random vector $\boldsymbol{\beta}^j$, and creates
a commitment to $\textbf{k}^j$ with:
$$
\textbf{K}^j := \text{Commit}(\textbf{k}^j, \boldsymbol{\beta}^j)
$$
$P_j$ sends $(\texttt{broadcast-in}, \texttt{sid}, \textbf{K}^j)$ to
the broadcast functionality $\mathcal{C}$.\\
$P_j$ waits to receive $(\texttt{broadcast-out}, \texttt{sid}, \textbf{K}^i)$
for each other party $i$.\\
\\
\textbf{Round $r$}\\
Each party $P_j$ computes $\bV^j_r := \varphi_r(\bV_1, \ldots, \bV_{r - 1})(\bx^j, \by^j, \bk^j)$.\\
Each party $P_j$ sends $(\texttt{prove}, \texttt{sid}, (\bx^j, \by^j, \balpha^j, \bk^j, \bbeta^j))$
to $\mathcal{F}(\texttt{ZK}, \psi_r)$, receiving $\pi^j_r$ in return.\\
Each party $P_j$ sends $(\bV^j_r, \pi^j_r)$ to every other party.\\
\\
After receiving $(\bV^i_r, \pi^i_r)$  from all other parties, $P_j$ checks,
for each $i$, that the proof is valid, by sending $(\texttt{verify}, (\bV^i_r, \bX^i, \bY^i, \bK^i), \pi^i_r)$ to
$\mathcal{F}(\texttt{ZK}, \psi_r)$, and aborting if the functionality returns $0$.\\
Each party $P_j$ then stores each $\bV^i_r$ as part of its output.
\end{aprotocol}

\begin{claim}
Provided that the discrete logarithm is hard in $\mathbb{G}$, Protocol \ref{prot:mpc} securely implements Functionality \ref{fun:mpc},
in the hybrid model of universally composable security,
given a zk functionality $\mathcal{F}(\text{ZK}, \varphi)$ (for arbitrary $\varphi$),
a broadcast functionality $\mathcal{C}$, as well as a common reference string
${(G, H) \in \mathbb{G}^2}$.
\end{claim}
\textbf{Proof:}\\
We prove this by constructing a simulator $\calS$ which uses
the ideal functionality $\mathcal{F}(\texttt{GRC})$ to perfectly
simulate an execution of the hybrid protocol against an adversary
$\mathcal{A}$.

We also work in the common reference string model, where the simulator
$\mathcal{S}$ chooses the bases $(G, H)$ for the Pedersen commitments.

We use this simulator $\calS$ to construct an adversary against
the discrete logarithm game.

Let $\calM \subseteq \calP$ be the set of malicious parties,
and $\calH \subseteq \calP$ be the set of honest parties. Naturally,
we have $\calH \cup \calM = \calP$ and $\calH \cap \calM = \emptyset$.

As an adversary against the discrete logarithm game,
$\calS$ receives $(G, H)$ as an instance 
of the discrete logarithm problem.

The simulator then proceeds as follows:\\
$\calS$ starts by setting $(G, H)$ as the common reference string.

\textbf{Round 0}:\\
For each $j \in \calH$, $\calS$ samples $\bK^j \xleftarrow{R} \mathbb{G}$.\\
For each $j \in \calM$,
$\calS$ waits to receive $(\texttt{broadcast-in}, \texttt{sid}, \bK^j)$.\\
$\calS$ then sends $(\texttt{broadcast-out}, \texttt{pid}_j, \texttt{sid}, \bK^j)$,
to all parties, for every $j \in \calP$, emulating $\mathcal{C}$.

\textbf{Interim}:\\
$\calS$ waits to receive $(\texttt{prove}, \texttt{sid}, (\bx^j, \by^j, \balpha^j, \bk^j, \bbeta^j))$
for each malicious ${j \in \calM}$,
playing the role of $\mathcal{F}(\texttt{ZK}, \psi_1)$.\\
$\calS$ checks, for each $j$, that:
$$
\begin{aligned}
\bX^j &\stackrel{?}{=} \bx^j \cdot G\\
\bY^j &\stackrel{?}{=} \by^j \cdot G + \balpha^j \cdot H\\
\bK^j &\stackrel{?}{=} \bk^j \cdot G + \bbeta^j \cdot H
\end{aligned}
$$
otherwise, $\calS$ sets $\texttt{bad-values}^j_1 \gets 1$.\\
$\calS$ records the values $\bx^j, \by^j, \balpha^j, \bk^j, \balpha^j$, for $j \in \calM$.\\

Now, in the real execution against $\mathcal{F}(\texttt{GRC})$,
with real honest parties $P_i$, for
each $j \in \calM$, the parties $\calS$ controls, $\calS$ sends
$(\texttt{input}, \texttt{sid}, \bx^j, \by^j, \balpha^j, \bk^j)$ to $\mathcal{F}(\texttt{GRC})$.\\
$\calS$ receives $(\texttt{output}, \texttt{sid}, \bV^1_1, \ldots, \bV^n_d)$ in return,
and records these values.

\textbf{Round $r$}:\\
For each round $r \in [d]$, $\calS$ proceeds as follows:\\
$\calS$ generates a new $\pi^i_r$ for each $i \in \calH$, and sends
$(\bV^i_r, \pi^i_r)$ to every malicious $P_j$, with $j \in \calM$.

Unless $r = 1$, $\calS$ waits to receive 
$(\texttt{prove}, \texttt{sid}, \hat{\bx}^j, \hat{\by}^j, \hat{\balpha}^j, \hat{\bk}^j, \hat{\bbeta}^j)$
from each malicious $P_j$, for $j \in \calM$, playing the role of $\mathcal{F}(\texttt{ZK}, \psi_r)$.\\
$\mathcal{S}$ then checks, for each $j$, that:
$$
\begin{aligned}
\bX^j &\stackrel{?}{=} \hat{\bx}^j \cdot G\\
\bY^j &\stackrel{?}{=} \hat{\by}^j \cdot G + \hat{\balpha}^j \cdot H\\
\bK^j &\stackrel{?}{=} \hat{\bk}^j \cdot G + \hat{\bbeta}^j \cdot H
\end{aligned}
$$
and sets $\texttt{bad-values}^j_r \gets 1$ otherwise.\\
The first check implies that $\hat{\bx^j} = \bx^j$. If it holds that
$\hat{\by}^j \neq \by^j$ or $\hat{\bk}^j \neq \bk^j$, then $\calS$ has
found a value $h$ such that $h \cdot G = H$, as shown in \todo{reference previous section},
and $\calS$ aborts, returning $h$.

(Including when $r = 1$) $\calS$ generates a new $\pi^j_r$, and returns $(\texttt{proof}, \pi^j_r)$,
playing the role of $\mathcal{F}(\texttt{ZK}, \psi_r)$.

Concurrently, $\calS$ plays the role of $\mathcal{F}(\texttt{ZK}, \psi_r)$,
responding to $(\texttt{verify}, (\hat{\bV}^i_r, \hat{\bX}^i, \hat{\bY}^i, \hat{\bK}^i), \pi)$
queries. $\calS$ checks that there exists some $j \in \mathcal{P}$ such that
$\pi^j_r = \pi$. $\calS$ then returns:
$$
\hat{\bV}^i_r \stackrel{?}{=} \bV^i_r \land
\hat{\bX}^i \stackrel{?}{=} \bX^i \land
\hat{\bY}^i \stackrel{?}{=} \bY^i \land
\hat{\bK}^i \stackrel{?}{=} \bK^i \land
\texttt{bad-values}^j_r \neq 1
$$

$\calS$ then waits to receive $(\hat{\bV}^j, \hat{\pi}^j_r)$ for
every malicious party $P_j$, with ${j \in \mathcal{M}}$.\\
$\calS$ then checks if the query $(\texttt{verify}, (\hat{\bV^j_r}, \bX^j, \bY^j, \bK^j), \hat{\pi}^j_r)$
would yield $1$, according to the logic in the section above.
(If $\hat{\pi}^j_r$ doesn't match anything, the check is considered to fail).
If this check fails, then $\calS$ simulates every honest $P_i$ aborting, with $i \in \calH$,
to abort, as if they'd seen an invalid proof themselves.

This concludes the simulation.

If $\calS$ aborts with a value $h$, then they've successfully
solved an instance of the discrete logarithm problem. Under our
assumption that this problem is hard, this happens with negligeable
probability.

We argue that if $\calS$ does not abort in this way, then the simulation
is perfect. For the first round, because pedersen commitments
are perfectly hiding, sampling a random $\bK^j$ has an identical
distribution as an honest party generating a pedersen commitment.
For the rest of the protocol, all of our checks are equivalent
to those made by honest parties. This is because the
$\bV^i_j$ values are necessarily computed correctly, and use
the inputs provided by the parties the adversary $\mathcal{A}$ controls.

Because our simulator $\calS$ is perfect, and doesn't
rewind the adversary $\mathcal{A}$, we conclude that our protocol
satisfies universally composable security, in the hybrid model.

$\square$

\subsection{Security Analysis}

\subsection{Practical Considerations}

\section{Applications}

\section{Limitations and Further Work}

\section{Conclusion}

\bibliographystyle{alpha}
\small \bibliography{bib}
\end{document}
