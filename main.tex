\include{preamble.tex}

\date{\today}
\title{MPC for Group Reconstruction Circuits}
\author{Lúcás Críostóir Meier}

\begin{document}

\maketitle

\begin{abstract}
    In this paper, we present a thing.
\end{abstract}

\section{Introduction}

\todo{Write the introduction}

\section{Background}

Throughout this paper, we let $\G$ denote a group of prime order $q$,
with generators $G$ and $H$. Let $\Fq$ denote the scalar field associated
with this group, and let $\Zq$ denote the additive group of elements
in this field.

We make heavy use of group homomorphisms throughout this paper.
We let
$$
\varphi(P_1, \ldots, P_m) : \mathbb{A} \to \mathbb{B}
$$
denote a homomorphism from $\mathbb{A}$ to $\mathbb{B}$, parameterized
by some public values $P_1, \ldots, P_m$. Commonly $\mathbb{A}$
will be a product of several groups $\mathbb{G}_1, \ldots, \mathbb{G}_n$,
in which case we'd write:
$$
\varphi(P_1, \ldots, P_m)(x_1, \ldots, x_n)
$$
to denote the application of $\varphi$ to an element $(x_1, \ldots, x_n)$
of the product group.
Such an element is sometimes treated as a vector $\textbf{x}$, in which case
we write $\varphi(P_1, \ldots, P_m)(\textbf{x})$.
We also often leave the public values $P_i$ implicit.

\subsection{Pedersen Commitments}

\subsection{Sigma Protocols}

\subsection{Maurer's \texorpdfstring{$\varphi$}{varphi}-Proof}

In \cite{maurer_unifying_2009}, Maurer generalized Schnorr's sigma 
protocol for knowledge of the discrete logarithm \cite{schnorr_efficient_1990} to a much larger class
of relations. In particular, Maurer provided a sigma protocol for
proving knowledge of the pre-image of a group homomorphism $\varphi$.
We denote this protocol as a ``$\varphi$-proof'', and recapitulate the scheme
here.

Given a homomorphism $\varphi : \mathbb{A} \to \mathbb{B}$, and a public value
$X \in \mathbb{B}$, the prover wants to demonstrate knowledge of a private
value $x \in \mathbb{A}$ such that $\varphi(x) = X$. The prover
does this by means of Protocol \ref{prot:phiproof}:

\begin{aprotocol}{prot:phiproof}{$\varphi$-Proof}
\[
\begin{aligned}
    &\textbf{Prover}&&\textbf{Verifier}\\
    &\text{knows } x \in \mathbb{A}&&\text{public } X \in \mathbb{B}\\
    \\
    &k \xleftarrow{R} \mathbb{A}&\\
    &K \gets \varphi(k)&\\
    &&\quad\overset{K}{\longrightarrow}\quad\\
    &&&c \xleftarrow{R} \mathbb{Z}/(p)\\
    &&\quad\overset{c}{\longleftarrow}\quad\\
    &s \gets k + c \cdot x\\
    &&\quad\overset{s}{\longrightarrow}\quad\\
    &&& \varphi(s) \overset{?}{=} K + c \cdot X\\
\end{aligned}
\]
\end{aprotocol}

Here, $p$ is chosen such that $\forall B \in \mathbb{B}.\ p \cdot B = 0$.
In practice, we'll set $p = q$, which will work perfectly for the groups
we use, which are all products of $\G$ or $\Zq$.

\begin{claim}
    Protocol \ref{prot:phiproof} is a valid sigma protocol.
\end{claim}

Completeness follows directly from the fact that $\varphi$ is a homomorphism.

For the HVZK property, the simulator $\mathcal{S}(X, c)$ works by generating
a random $s \xleftarrow{R} \mathbb{A}$, and then setting $K := \varphi(S) - c \cdot X$.

Finally, we prove $2$-extractability. Given two verifying transcripts
$(K, c, s)$ and $(K, c', s')$ sharing the first message, we extract
a value $\hat{x}$ satisfying $\varphi(\hat{x}) = X$ as follows:

$$
\begin{aligned}
\varphi(s) - c \cdot X &= K = \varphi(s') - c' \cdot X\\
\varphi(s) - \varphi(s') &= c \cdot X - c' \cdot X\\
\frac{1}{c - c'} \cdot \varphi(s - s') &= X\\
\varphi \left(\frac{s - s'}{c - c'}\right) &= X
\end{aligned}
$$

Thus, defining $\hat{x} := (s - s') / (c - c')$, we successfully extract
a valid pre-image.

We conclude that the protocol is a valid sigma protocol.

$\blacksquare$

Maurer's protocol can also work even in the case where the order of
the groups are not known, but this makes the challenge generation
a bit more complicated, and we don't need this functionality in
this work.

\subsection{UC Security and the Hybrid Model}

\subsection{Ideal Functionalities for Sigma Protocols}

\begin{afunctionality}{fun:zk}{Zero-Knowledge Functionality $\mathcal{F}(\texttt{ZK}, \varphi)$}
A functionality $\mathcal{F}$ for parties $P_1, \ldots, P_n$.\\
\\
On input $(\texttt{prove}, \sid, X, x)$ from $P_i$:\\
$\mathcal{F}$ checks that $\sid$ has not been used by $P_i$ before.\\
$\mathcal{F}$ checks that $\varphi(x) \stackrel{?}{=} X$.\\
$\mathcal{F}$ generates a new token $\pi$, and sets $X_\pi \gets X$.\\
$\mathcal{F}$ replies with $(\texttt{proof}, \pi)$.\\
\\
On input $(\texttt{verify}, X, \pi)$:\\
$\mathcal{F}$ replies with $(\texttt{verify-result}, X_\pi \stackrel{?}{=} X)$.\\


\end{afunctionality}

\subsection{Broadcast Functionalities}

\begin{afunctionality}{fun:broadcast}{Authenticated Broadcast Functionality $\mathcal{C}$}
A functionality $\mathcal{C}$ for parties $P_1, \ldots, P_n$.\\
\\
On receiving $(\texttt{broadcast-in}, \sid, m)$ from $P_i$:\\
$\mathcal{C}$ checks that $\sid$ has not been used by $P_i$ before.\\
$\mathcal{C}$ sends $(\texttt{broadcast-out}, \pid_i, \sid, m)$ to every party $P_j$.
\end{afunctionality}

\section{Group Reconstruction Circuits}

\subsection{Formal Definition}

\subsection{Normalized Form}

\section{MPC Protocol for GRCs}

\subsection{Ideal Functionality}

\begin{afunctionality}{fun:mpc}{GRC functionality $\mathcal{F}(\texttt{GRC}, \Phi, \textbf{X}^j, \textbf{Y}^j)$}
A functionality $\mathcal{F}$ for parties $P_1, \ldots, P_n$.\\
\\
After receiving
$(\texttt{input}, \texttt{sid}, \textbf{x}^j, \textbf{y}^j, \boldsymbol{\alpha}^j, \textbf{k}^j)$ from every party $P_j$:\\
$\mathcal{F}$ checks, for every $j \in [n]$, that:
$$
\begin{aligned}
    \textbf{X}^j &\stackrel{?}{=} \textbf{x}^j \cdot G\\
    \textbf{Y}^j &\stackrel{?}{=} \textbf{y}^j \cdot G + \boldsymbol{\alpha}^j \cdot H\\
\end{aligned}
$$
$\mathcal{F}$ computes, for each round $r \in [d]$:
$$
\begin{aligned}
    \textbf{V}^j_{r} &:= \varphi_{r}(\textbf{V}_{1}, \ldots, \textbf{V}_{r - 1})(
        \textbf{x}^j, \textbf{y}^j, \textbf{k}^j
    )\\
    \textbf{V}_r &:= \sum_j \textbf{V}^j_r
\end{aligned}
$$\\
$\mathcal{F}$ sends $(\texttt{output}, \texttt{sid}, \textbf{V}^1_1, \ldots, \textbf{V}^n_d)$ to every party $P_j$.
\end{afunctionality}

\subsection{Protocol}

$$
\psi_r(\textbf{x}, \textbf{y}, \boldsymbol{\alpha}, \textbf{k}, \boldsymbol{\beta})
:= (\varphi_r(\textbf{x}, \textbf{y}, \textbf{j}), \bx \cdot G, \text{Commit}(\textbf{y}, \boldsymbol{\alpha}), \text{Commit}(\textbf{k}, \boldsymbol{\beta}))
$$

\begin{aprotocol}{prot:mpc}{MPC protocol for $\Phi, \textbf{X}^j, \textbf{Y}^j$}

Each party $P_j$ has inputs $\textbf{x}^j$ and $\textbf{y}^j$, committed to
by $\textbf{X}^j$ and $\textbf{Y}^j$.
They also have decommitments $\boldsymbol{\alpha}^j$ for $\textbf{Y}^j$.
Each party $P_j$ also has a vector $\textbf{k}^j$, which honest parties will
have generated randomly.\\
\\
\textbf{Round 0}\\
Each party $P_j$ generates a random vector $\boldsymbol{\beta}^j$, and creates
a commitment to $\textbf{k}^j$ with:
$$
\textbf{K}^j := \text{Commit}(\textbf{k}^j, \boldsymbol{\beta}^j)
$$
$P_j$ sends $(\texttt{broadcast-in}, \texttt{sid}, \textbf{K}^j)$ to
the broadcast functionality $\mathcal{C}$.\\
\\
\textbf{Round $r$}\\
Each party $P_j$ computes $\bV^j_r := \varphi_r(\bV_1, \ldots, \bV_{r - 1})(\bx^j, \by^j, \bk^j)$.\\
Each party $P_j$ sends $(\texttt{prove}, \texttt{sid}, (\bV^j_r, \bX^j, \bY^j, \bK^j), (\bx^j, \by^j, \balpha^j, \bk^j, \bbeta^j))$
to $\mathcal{F}(\texttt{ZK}, \psi_r)$, receiving $\pi^j_r$ in return.\\
Each party $P_j$ sends $(\bV^j_r, \pi^j_r)$ to every other party.\\
\\
After receiving $(\bV^i_r, \pi^i_r)$  from all other parties, $P_j$ checks,
for each $i$, that the proof is valid, by sending $(\texttt{verify}, (\bV^i_r, \bX^i, \bY^i, \bK^i), \pi^i_r)$ to
$\mathcal{F}(\texttt{ZK}, \psi_r)$, and aborting if the functionality returns $0$.\\
Each party $P_j$ then stores each $\bV^i_r$ as part of its output.
\end{aprotocol}


\subsection{Security Analysis}

\subsection{Practical Considerations}

\section{Applications}

\section{Limitations and Further Work}

\section{Conclusion}

\bibliographystyle{alpha}
\small \bibliography{bib}
\end{document}
